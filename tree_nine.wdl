version 1.0

import "https://raw.githubusercontent.com/aofarrel/SRANWRP/v1.1.26/tasks/processing_tasks.wdl" as processing
import "./matutils_and_friends.wdl" as matWDLlib

# User notes:
# * If user doesn't define input_tree, a rudimentary 7K sample tree will serve as the base tree. This base tree
#   doesn't represent genetic diversity of MTBC well and should not be used for anything besides quick testing.
# * Should be run with --copy-input-files on miniwdl (required if clustering, may work w/o it if not clustering)
# * It's not recommended to use a pre-combined diff file, especially if clustering

# Dev notes:
# * Anything marked !ForwardReference is using a bogus fallback value with select_first().
# * We're going with all_samples and old_samples instead of directly asking for new_samples so we can
#   run this more easily on Terra -- just input the most recent myco_raw batch's samples (which will
#   be the entire data table, including call cached previous samples) as all_samples, and then slap
#   in the second-most-recent myco_raw's batch samples as old_samples.

workflow Tree_Nine {
	input {
		Array[File] diffs
		File? input_tree
		String todays_date
		
		# matUtils/UShER options
		Boolean detailed_clades          = false
		Float?  max_low_coverage_sites
		File? matutils_clade_annotations
		String? reroot_to_this_node
		Boolean skip_summary             = true

		# related to clustering/distance matrix
		Boolean identify_clusters              = false
		Boolean cluster_entire_tree            = false
		File? persistent_cluster_meta
		File? persistent_cluster_ids
		File? previous_run_cluster_json
		File? persistent_denylist
		File? special_samples

		# related to putting clusters on Microreact
		Boolean upload_clusters_to_microreact  = false
		File? microreact_blank_template_json
		File? microreact_key
		File? microreact_update_template_json
		String? microreact_shareemail
		
		# rarely used files (see parameter_meta)
		Array[File]? coverage_reports
		File? ref_genome               # do not define this if you're using H37Rv!
		
		# output file names, extension not included
		Array[String]? rename_samples
		String out_prefix              = "tree"
		String out_prefix_summary      = out_prefix + "_"
		String in_prefix_summary       = basename(select_first([input_tree, "for_debugging_only__tb_7K_noQC_diffs_mask2ref.L.fixed.pb"]))
		String out_diffs               = "_combined"
		String out_tree_annotated_pb   = "_annotated"
		String out_tree_nextstrain     = "_auspice"
		String out_tree_nwk            = "_nwk"
		String out_tree_taxonium       = "_taxonium"
		String out_tree_raw_pb         = "_raw"
		
	}

	parameter_meta {
		diffs: "Array of diff files"
		input_tree: "The base tree samples will be placed upon; will fall back to a test tree on ~7K TB samples from SRA if not defined. Do NOT use the default test tree for publication, it's not filtered nor a good representative of MTBC diversity; it's just for quick tests!"
		
		matutils_clade_annotations: "Two column TSV for clade annotation via matUtils"
		cluster_entire_tree: "If true, matrix and cluster all samples on tree; if false, only matrix and cluster special_samples (if defined) or newly added samples. Does NOT affect backmask clustering."
		cluster_max_distance: "Maximum SNP distance between two samples for them to be in the same cluster"
		coverage_reports: "NOT USUALLY NEEDED - Single line text files generated by Lily's vcf to diff script, used to filter samples with low overall coverage. By default, myco's vcf_to_diff.py filters sites per site coverage, so this isn't typically needed here in Tree Nine."
		detailed_clades: "usher_sampled_diff -D"
		max_low_coverage_sites: "Maximum percentage of low coverage sites a sample can have before throwing it out (requires coverage_reports, does not apply to backmasked diffs)"
		special_samples: "Provide an override file containing names of the only samples to consider for matrix and clustering. If this isn't defined, matrixing and clustering is done on either entire tree (if cluster_entire_tree) or all samples with a diff file (if not cluster_entire_tree)."
		subtree_context_samples: "If make_subtrees, each cluster subtree gets this number of non-cluster context samples"
		ref_genome: "Reference genome, equivalent to UShER's ref argument, default is H37Rv (M tuberculosis)"
		rename_samples: "For file at index i in diffs[i], rename it to the corresponding string at rename_samples[i]."
		reroot_to_this_node: "matUtils extract -y (Reroot the output tree relative to this node, leave blank to not reroot)"
		out_prefix: "Prefix for all output files"
		skip_summary: "Do not run matutils summary on any of the trees"
		upload_clusters_to_microreact: "If you know, you know"
	}

	call processing.cat_files as cat_diff_files {
		input:
			files = diffs,
			out_filename = out_prefix + out_diffs + ".diff",
			keep_only_unique_lines = false,
			keep_only_unique_files = true,
			removal_candidates = coverage_reports,
			removal_threshold = max_low_coverage_sites,
			first_lines_out_filename = "samples_added",
			overwrite_first_lines = rename_samples
	}

	File special_samples_added = select_first([special_samples, cat_diff_files.first_lines, usher_sampled_diff.usher_tree]) #!ForwardReference

	if(!(skip_summary)) {
		if (defined(input_tree)) {
			String basename_input_mat = basename(select_first([input_tree, ""]))

			# iff there is a metadata tsv, annotate input tree with it before summarizing
			if (defined(matutils_clade_annotations)) {
				String annotated = "annotated_"
				call matWDLlib.annotate as annotate_input_tree {
					input:
						input_mat = select_first([input_tree, usher_sampled_diff.usher_tree]), #!ForwardReference
						metadata_tsv = select_first([matutils_clade_annotations, usher_sampled_diff.usher_tree]), #!ForwardReference
						outfile_annotated = "input_annotated_" + basename_input_mat + ".pb"
				}
			}

			File possibly_annotated_input_tree = select_first([annotate_input_tree.annotated_tree, input_tree])
			String annotated_or_blank = select_first([annotated, ""])

			call matWDLlib.summarize as summarize_input_tree {
				input:
					input_mat = possibly_annotated_input_tree,
					prefix_outs = in_prefix_summary + annotated_or_blank
			}
		}
	}

	call matWDLlib.usher_sampled_diff as usher_sampled_diff {
		input:
			detailed_clades = detailed_clades,
			diff = cat_diff_files.outfile,
			input_mat = input_tree,
			output_mat = "max" + out_prefix + out_tree_raw_pb + ".pb",
			ref_genome = ref_genome
	}

	if (defined(matutils_clade_annotations)) {
		call matWDLlib.annotate as annotate_usher {
			input:
				input_mat = usher_sampled_diff.usher_tree,
				metadata_tsv = select_first([matutils_clade_annotations, usher_sampled_diff.usher_tree]), # bogus fallback
				outfile_annotated = "max" + out_prefix + out_tree_annotated_pb + ".pb"
		}
	}

	File possibly_annotated_maximal_output_tree = select_first([annotate_usher.annotated_tree, usher_sampled_diff.usher_tree])

	if(defined(reroot_to_this_node)) {

		if(!(skip_summary)) {
			call matWDLlib.summarize as summarize_before_reroot {
				input:
					input_mat = possibly_annotated_maximal_output_tree,
					prefix_outs = "maximal_before_reroot"
			}
		}

		call matWDLlib.reroot as reroot_usher {
			input:
				input_mat = possibly_annotated_maximal_output_tree,
				reroot_to_this_node = select_first([reroot_to_this_node, ""])
		}
	}

	File final_maximal_output_tree = select_first([reroot_usher.rerooted_tree, possibly_annotated_maximal_output_tree])

	# defined(matutils_clade_annotations)   defined(reroot_to_this_node)          final_maximal_output_tree
	# ----------------------------------------------------------------------------------------------------------------
	#       true                       true                    annotated and rerooted
	#       true                      false                    annotated
	#       false                      true                    rerooted
	#       false                     false                    neither, just the output usher_sampled_diff.usher_tree

	call matWDLlib.convert_to_taxonium as to_taxonium {
		input:
			input_mat = final_maximal_output_tree,
			outfile_taxonium = "max" + out_prefix + out_tree_taxonium + ".jsonl.gz"
	}

	if (identify_clusters) {
		call matWDLlib.cluster_CDPH_method as cluster {
			input:
				shareemail = microreact_shareemail,
				input_mat_with_new_samples = final_maximal_output_tree,
				special_samples = special_samples_added,
				combined_diff_file = cat_diff_files.outfile,
				only_matrix_special_samples = !(cluster_entire_tree),
				persistent_ids = persistent_cluster_ids,
				persistent_cluster_meta = persistent_cluster_meta,
				microreact_key = microreact_key,
				microreact_update_template_json = microreact_update_template_json,
				microreact_blank_template_json = microreact_blank_template_json,
				previous_run_cluster_json = previous_run_cluster_json,
				persistent_denylist = persistent_denylist,
				upload_clusters_to_microreact = upload_clusters_to_microreact,
				today = todays_date
		}

		call matWDLlib.convert_to_nextstrain_single_terra_compatiable as to_nextstrain_cluster {
			input:
				input_mat = final_maximal_output_tree,
				outfile_nextstrain = "max_cluster_" + out_prefix + out_tree_nextstrain + ".json",
				one_metadata_file = cluster.samp_cluster
		}
	}

	if (!(identify_clusters)) {
		call matWDLlib.convert_to_nextstrain_single_terra_compatiable as to_nextstrain {
				input:
					input_mat = final_maximal_output_tree,
					outfile_nextstrain = "max" + out_prefix + out_tree_nextstrain + ".json"
			}
	}
	

	if(!(skip_summary)) {
		# summarizes the output tree whether or not it was rerooted. the
		# task name just makes it clear this isn't the same as 
		# summarize_before_reroot
		call matWDLlib.summarize as summarize_after_reroot {
			input:
				input_mat = final_maximal_output_tree,
				prefix_outs = "max" + out_prefix_summary
		}
	}
	
	output {
		# This has a ton of outputs and we want them to be easily viewable in Terra's UI, so they have a consistent naming scheme:
		#
		# [BM/NB/IN]_[BIG/CLS/UNC]_[THING]_[FILETYPE]
		# where:
		# * BM = backmask, NB = not backmasked, IN = "raw" input
		# * BIG = big tree, CLS = cluster, UNC = unclustered

		# big trees - protobuff
		#
		# note that tree_usher_rerooted is annotated if defined(matutils_clade_annotations), but tree_usher_annotated is NOT rerooted
		# even if defined(reroot_to_this_node) -- this was done on purpose so people can get two annotated trees if they
		# want to easily compare the tree before and after rerooting
		#
		File  BIG_tree_usher = usher_sampled_diff.usher_tree                                 
		File? BIG_tree_reroot = reroot_usher.rerooted_tree
		File? BIG_tree_ushanno = annotate_usher.annotated_tree

		# big trees - other formats
		#
		# iff defined(reroot_to_this_node), these are based on usher_tree_rerooted
		# else, these are based on usher_tree_raw (and usher_tree_rerooted doesn't exist)
		#
		File?  BIG_tree_nwk = cluster.abig_tree
		File   BIG_tree_taxonium = to_taxonium.taxonium_tree
		File?  BIG_tree_json_noanno = to_nextstrain.nextstrain_singular_tree
		File?  BIG_tree_json_clusteranno = to_nextstrain_cluster.nextstrain_singular_tree
		#File  nb_unc_tree_nwk = cluster.unclustered_tree_nwk
		Array[File]? unclustered_subtrees = cluster.unclustered_subtrees

		# cluster subtrees
		# ultimately derived from nb_big_tree_nwk/bm_big_tree_nwk
		#
		#Array[File]? CLUSTER_trees_json = cluster.cluster_trees_json
		Array[File]?  CLUSTER_trees_nwk  = cluster.acluster_trees
		#Array[File]? BM_CLUSTER_trees_json = cluster.cluster_trees_json
		Array[File]?  BM_CLUSTER_trees_nwk = cluster.bcluster_trees

		# distance matrices
		File?         BIG_dmatrix = cluster.abig_matrix
		Array[File]?  CLUSTER_dmatrices = cluster.acluster_matrices
		Array[File]?  BM_CLUSTER_dmatrices = cluster.bcluster_matrices

		# other cluster information
		File? new_persistent_ids = cluster.new_persistent_ids
		File? new_persistent_meta = cluster.new_persistent_meta
		File? nearest_and_furtherst_info = cluster.nearest_and_furtherst_info
		File? final_cluster_information_json = cluster.final_cluster_information_json
		Int?  nb_n_clusters = cluster.n_big_clusters
		Int?  nb_n_samps_unclustered = cluster.n_unclustered
		Int?  nb_n_samps_clustered = cluster.n_samples_in_clusters
		Int?  nb_n_samps_processed = cluster.n_samples_processed
		#Array[String]? nb_unc_samples = cluster.unclustered_samples

		# summaries
		File? in_summary = summarize_input_tree.summary
		File? nb_summary_preroot = summarize_before_reroot.summary
		File? nb_summary_final = summarize_after_reroot.summary
		
		# sample information
		File? in_list_samples = summarize_input_tree.samples
		File? nb_list_samples_preroot = summarize_before_reroot.samples     # iff defined(reroot_to_this_node)
		File? nb_list_samples_final = summarize_after_reroot.samples

		Array[String] samples_added = read_lines(special_samples_added)
		Array[String] samples_dropped = cat_diff_files.removed_files

	}
}
