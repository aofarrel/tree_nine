# Tree Nine version 0.0.16-REPRO
# This is an archived version of Tree Nine that exists solely for reproducing published results -- it is HIGHLY recommended you use a more recent version!
# The "version 1.0" string below references the WDL syntax version
version 1.0

import "https://raw.githubusercontent.com/aofarrel/SRANWRP/v1.1.18/tasks/processing_tasks.wdl" as processing
import "https://raw.githubusercontent.com/aofarrel/diffdiff/0.0.8/diffdiff.wdl" as dd
import "./matutils_and_friends.wdl" as matWDLlib

# User notes:
# * miniwdl users should use --copy-input-files
# * If input_tree is not provided, a tree of 7K samples from SRA will serve as the base tree -- this base tree is
#   very outdated and shouldn't be used for actual analysis!
# * You probably don't want to enable cross_sample_masking as it'll mask all of your input diffs to each other,
#   such that any position that is low-coverage in *any* diff will be masked across *all* diffs. This feature is
#   designed for people who like Bionumerics' way of doing things, since this is one of the ways they filter SNPs.
#   However, there's a much better implementation of cross_sample_masking (aka "backmasking") in the main version of
#   this pipeline which uses matUtils mask. This version, 0.0.16-REPRO, uses a much more rudimentary implementation
#   that scales poorly past roughly 70 samples.
# * The distance matrix for the clustering script must fit in memory -- if you need to matrix >30,000 samples at once
#   you may want to bump up the resources (or switch to the main branch which is more efficient)
# * If using cross-sampled-masking, diff files must not be pre-combined (ie, must be individual .diff files)

# Dev notes:
# Anything marked !ForwardReference is using a bogus fallback value with select_first().

workflow Tree_Nine {
	input {
		Array[File] diffs
		File? input_tree
		File? matutils_annotations
		
		# options
		Boolean cross_sample_masking     = false
		Boolean cluster_everything       = false
		Int     cluster_max_distance     = 20
		Boolean detailed_clades          = false
		Boolean make_cluster_subtrees    = true
		Float?  max_low_coverage_sites
		Int     subtree_context_samples  = 0
		String? reroot_to_this_node
		Boolean skip_summary             = true
		
		# rarely used files
		Array[File]? coverage_reports  # by default vcf_to_diff.py filters sites per site coverage and both 
		                               # make_diff_from_vcf_and_mask and make_mask_and_diff WDL tasks filter
		                               # samples by overall coverage, so this is rarely needed in Tree Nine
		File? special_samples
		File? ref_genome               # equivalent to USHER's ref argument, otherwise assumes H37Rv
		
		# output file names, extension not included
		Array[String]? rename_samples
		String out_prefix              = "tree"
		String out_prefix_summary      = out_prefix + "_"
		String in_prefix_summary       = basename(select_first([input_tree, "for_debugging_only__tb_7K_noQC_diffs_mask2ref.L.fixed.pb"]))
		String out_diffs               = "_combined"
		String out_tree_annotated_pb   = "_annotated"
		String out_tree_nextstrain     = "_auspice"
		String out_tree_nwk            = "_nwk"
		String out_tree_taxonium       = "_taxonium"
		String out_tree_raw_pb         = "_raw"
		
	}

	parameter_meta {
		diffs: "Array of diff files"
		input_tree: "usher_sampled_diff -i (If not defined, falls back on a large SRA tree)"
		matutils_annotations: "Two column TSV for clade annotation via matUtils"

		cross_sample_masking: "Enable backmasking of samples for which we have diff files (when backmasking, diffs will be processed twice, but max_low_coverage_sites only applies to the first processing)"
		cluster_everything: "If true, matrix and cluster all samples on tree; if false, only matrix and cluster special_samples (if defined) or newly added samples. Does NOT affect backmask clustering."
		cluster_max_distance: "Maximum SNP distance between two samples for them to be in the same cluster"
		coverage_reports: "NOT USUALLY NEEDED - Single line text files generated by Lily's vcf to diff script, used to filter samples with low overall coverage"
		detailed_clades: "usher_sampled_diff -D"
		make_cluster_subtrees: "If true, make nextstrain subtrees of clusters in addition to one big nextstrain tree"
		max_low_coverage_sites: "Maximum percentage of low coverage sites a sample can have before throwing it out (requires coverage_reports)"
		special_samples: "Only matrix anad cluster samples in this file instead of clustering only needed added samples. Does NOT affect backmask clustering."
		subtree_context_samples: "If make_subtrees, each cluster subtree gets this number of non-cluster context samples"
		ref_genome: "Reference genome, equivalent to UShER's ref argument, default is H37Rv (M tuberculosis)"
		rename_samples: "For file at index i in diffs[i], rename it to the corresponding string at rename_samples[i]."
		reroot_to_this_node: "matUtils extract -y (Reroot the output tree relative to this node, leave blank to not reroot)"
		out_prefix: "Prefix for all output files"
		skip_summary: "Do not run matutils summary on any of the trees"
	}

	call processing.cat_files as cat_diff_files {
		input:
			files = diffs,
			out_filename = out_prefix + out_diffs + ".diff",
			keep_only_unique_lines = false,
			removal_candidates = coverage_reports,
			removal_threshold = max_low_coverage_sites,
			first_lines_out_filename = "samples_added",
			overwrite_first_lines = rename_samples
	}

	File special_samples_added = select_first([special_samples, cat_diff_files.first_lines, usher_sampled_diff.usher_tree]) #!ForwardReference

	if(!(skip_summary)) {
		if (defined(input_tree)) {
			String basename_input_mat = basename(select_first([input_tree, ""]))

			# iff there is a metadata tsv, annotate input tree with it before summarizing
			if (defined(matutils_annotations)) {
				String annotated = "annotated_"
				call matWDLlib.annotate as annotate_input_tree {
					input:
						input_mat = select_first([input_tree, usher_sampled_diff.usher_tree]), #!ForwardReference
						metadata_tsv = select_first([matutils_annotations, usher_sampled_diff.usher_tree]), #!ForwardReference
						outfile_annotated = "input_annotated_" + basename_input_mat + ".pb"
				}
			}

			File possibly_annotated_input_tree = select_first([annotate_input_tree.annotated_tree, input_tree])
			String annotated_or_blank = select_first([annotated, ""])

			call matWDLlib.summarize as summarize_input_tree {
				input:
					input_mat = possibly_annotated_input_tree,
					prefix_outs = in_prefix_summary + annotated_or_blank
			}
		}
	}

	call matWDLlib.usher_sampled_diff as usher_sampled_diff {
		input:
			detailed_clades = detailed_clades,
			diff = cat_diff_files.outfile,
			input_mat = input_tree,
			output_mat = "max" + out_prefix + out_tree_raw_pb + ".pb",
			ref_genome = ref_genome
	}

	if (defined(matutils_annotations)) {
		call matWDLlib.annotate as annotate_usher {
			input:
				input_mat = usher_sampled_diff.usher_tree,
				metadata_tsv = select_first([matutils_annotations, usher_sampled_diff.usher_tree]), # bogus fallback
				outfile_annotated = "max" + out_prefix + out_tree_annotated_pb + ".pb"
		}
	}

	File possibly_annotated_maximal_output_tree = select_first([annotate_usher.annotated_tree, usher_sampled_diff.usher_tree])

	if(defined(reroot_to_this_node)) {

		if(!(skip_summary)) {
			call matWDLlib.summarize as summarize_before_reroot {
				input:
					input_mat = possibly_annotated_maximal_output_tree,
					prefix_outs = "maximal_before_reroot"
			}
		}

		call matWDLlib.reroot as reroot_usher {
			input:
				input_mat = possibly_annotated_maximal_output_tree,
				reroot_to_this_node = select_first([reroot_to_this_node, ""])
		}
	}

	File final_maximal_output_tree = select_first([reroot_usher.rerooted_tree, possibly_annotated_maximal_output_tree])

	# defined(matutils_annotations)   defined(reroot_to_this_node)          final_maximal_output_tree
	# ----------------------------------------------------------------------------------------------------------------
	#       true                       true                    annotated and rerooted
	#       true                      false                    annotated
	#       false                      true                    rerooted
	#       false                     false                    neither, just the output usher_sampled_diff.usher_tree

	call matWDLlib.convert_to_newick as to_newick {
		input:
			input_mat = final_maximal_output_tree,
			outfile_nwk = "max" + out_prefix + out_tree_nwk + ".nwk"
	}

	call matWDLlib.convert_to_taxonium as to_taxonium {
		input:
			input_mat = final_maximal_output_tree,
			outfile_taxonium = "max" + out_prefix + out_tree_taxonium + ".jsonl.gz"
	}

	call matWDLlib.matrix_and_find_clusters as dmatrix {
		input:
			input_nwk = to_newick.newick_tree,
			special_samples = special_samples_added,
			only_matrix_special_samples = !(cluster_everything),
			distance = cluster_max_distance
	}

	if (make_cluster_subtrees) {
		call matWDLlib.convert_to_nextstrain_subtrees_by_cluster as to_nextstrain_subtrees {
			input:
				input_mat = final_maximal_output_tree,
				metadata_tsv = dmatrix.out_clusters,
				grouped_clusters = dmatrix.groupped_clusters,
				context_samples = subtree_context_samples
		}

		call matWDLlib.convert_to_newick_subtrees_by_cluster as to_nwk_subtrees {
			input:
				input_mat = final_maximal_output_tree,
				metadata_tsv = dmatrix.out_clusters,
				grouped_clusters = dmatrix.groupped_clusters,
				context_samples = subtree_context_samples
		}
	}

	call matWDLlib.convert_to_nextstrain_single_terra_compatiable as to_nextstrain {
		input:
			input_mat = final_maximal_output_tree,
			outfile_nextstrain = "max" + out_prefix + out_tree_nextstrain + ".json",
			one_metadata_file = dmatrix.out_clusters
	}

	if(!(skip_summary)) {
		# summarizes the output tree whether or not it was rerooted. the
		# task name just makes it clear this isn't the same as 
		# summarize_before_reroot
		call matWDLlib.summarize as summarize_after_reroot {
			input:
				input_mat = final_maximal_output_tree,
				prefix_outs = "max" + out_prefix_summary
		}
	}
	
	if(cross_sample_masking) {
		call dd.diffdiff_backmask as backmask {
			input:
				diffs = diffs
		}
		
		call processing.cat_files as cat_backmasked_diff_files {
			input:
				files = backmask.backmasked_diffs,
				out_filename = "BM" + out_prefix + out_diffs + ".diff",
				keep_only_unique_lines = false,
				first_lines_out_filename = "backmasked_samples_added",
				overwrite_first_lines = rename_samples
		}
		
		call matWDLlib.usher_sampled_diff as backmask_usher_sampled_diff {
			input:
				detailed_clades = detailed_clades,
				diff = cat_backmasked_diff_files.outfile,
				input_mat = input_tree,
				output_mat = "bm" + out_prefix + out_tree_raw_pb + ".pb",
				ref_genome = ref_genome
		}
	
		if (defined(matutils_annotations)) {
			call matWDLlib.annotate as annotate_backmasked {
				input:
					input_mat = backmask_usher_sampled_diff.usher_tree,
					metadata_tsv = select_first([matutils_annotations, backmask_usher_sampled_diff.usher_tree]), # bogus fallback
					outfile_annotated = "bm" + out_prefix + out_tree_annotated_pb + ".pb"
			}
		}
	
		File possibly_annotated_backmask_output_tree = select_first([annotate_backmasked.annotated_tree, backmask_usher_sampled_diff.usher_tree])
	
		if(defined(reroot_to_this_node)) {
	
			if(!(skip_summary)) {
				call matWDLlib.summarize as summarize_backmask_before_reroot {
					input:
						input_mat = possibly_annotated_backmask_output_tree,
						prefix_outs = "backmask_before_reroot"
				}
			}
	
			call matWDLlib.reroot as reroot_backmask {
				input:
					input_mat = possibly_annotated_backmask_output_tree,
					reroot_to_this_node = select_first([reroot_to_this_node, ""])
			}
		}
	
		File final_backmask_tree = select_first([reroot_backmask.rerooted_tree, possibly_annotated_backmask_output_tree])
	
		call matWDLlib.convert_to_newick as backmask_newick {
			input:
				input_mat = final_backmask_tree,
				outfile_nwk = "bm" + out_prefix + out_tree_nwk + ".nwk"
		}
	
		call matWDLlib.convert_to_taxonium as backmask_taxonium {
			input:
				input_mat = final_backmask_tree,
				outfile_taxonium = "bm" + out_prefix + out_tree_taxonium + ".jsonl.gz"
		}
		
		File backmasked_sample_names = select_first([cat_backmasked_diff_files.first_lines, usher_sampled_diff.usher_tree])
	
		call matWDLlib.matrix_and_find_clusters as backmask_dmatrix {
			input:
				input_nwk = backmask_newick.newick_tree,
				special_samples = backmasked_sample_names,
				only_matrix_special_samples = !(cluster_everything),
				distance = cluster_max_distance
		}

		if (make_cluster_subtrees) {
			call matWDLlib.convert_to_nextstrain_subtrees_by_cluster as backmask_nextstrain_subtrees {
				input:
					input_mat = final_backmask_tree,
					metadata_tsv = backmask_dmatrix.out_clusters,
					grouped_clusters = backmask_dmatrix.groupped_clusters,
					context_samples = subtree_context_samples,
					prefix = "bm_"
			}

			call matWDLlib.convert_to_newick_subtrees_by_cluster as backmask_nwk_subtrees {
				input:
					input_mat = final_backmask_tree,
					metadata_tsv = backmask_dmatrix.out_clusters,
					grouped_clusters = backmask_dmatrix.groupped_clusters,
					context_samples = subtree_context_samples,
					prefix = "bm_"
			}
		}

		call matWDLlib.convert_to_nextstrain_single_terra_compatiable as backmask_nextstrain {
			input:
				input_mat = final_backmask_tree,
				outfile_nextstrain = "bm" + out_prefix + out_tree_nextstrain + ".json",
				one_metadata_file = backmask_dmatrix.out_clusters
		}
	
		if(!(skip_summary)) {
			call matWDLlib.summarize as summarize_backmask {
				input:
					input_mat = final_backmask_tree,
					prefix_outs = "bm" + out_prefix_summary
			}
		}
	}
	
	output {
		# trees - protobuff
		#
		# note that tree_usher_rerooted is annotated if defined(matutils_annotations), but tree_usher_annotated is NOT rerooted
		# even if defined(reroot_to_this_node) -- this was done on purpose so people can get two annotated trees if they
		# want to easily compare the tree before and after rerooting
		File  tree_usher = usher_sampled_diff.usher_tree                                 
		File? tree_usher_reroot = reroot_usher.rerooted_tree
		File? tree_usher_anno = annotate_usher.annotated_tree
		File? bm_usher = backmask_usher_sampled_diff.usher_tree
		File? bm_usher_reroot = reroot_backmask.rerooted_tree
		File? bm_usher_anno = annotate_backmasked.annotated_tree

		# trees - other formats
		#
		# iff defined(reroot_to_this_node), these are based on usher_tree_rerooted
		# else, these are based on usher_tree_raw (and usher_tree_rerooted doesn't exist)
		File  tree_nwk = to_newick.newick_tree
		File  tree_taxonium = to_taxonium.taxonium_tree
		File tree_nextstrain = to_nextstrain.nextstrain_singular_tree 
		Array[File]? subtrees_nextstrain = to_nextstrain_subtrees.nextstrain_subtrees
		Array[File]? subtrees_nwk = to_nwk_subtrees.newick_subtrees
		File? bm_nwk = backmask_newick.newick_tree
		File? bm_taxonium = backmask_taxonium.taxonium_tree
		File? bm_nextstrain = backmask_nextstrain.nextstrain_singular_tree
		Array[File]? subtrees_nextstrain_bm = backmask_nextstrain_subtrees.nextstrain_subtrees
		Array[File]? subtrees_nwk_bm = backmask_nwk_subtrees.newick_subtrees
		
		# summaries
		File? summary_input = summarize_input_tree.summary
		File? summary_maximal_output = summarize_after_reroot.summary
		File? summary_maximal_output_before_reroot = summarize_before_reroot.summary
		File? summary_backmask_before_reroot = summarize_backmask_before_reroot.summary
		File? summary_backmask = summarize_backmask.summary

		# cluster information
		File clusters_anno_max = dmatrix.out_clusters
		Array[File] cluster_dmatrices_max = dmatrix.out_matrices
		Int clusters_max = dmatrix.n_clusters
		Int clustered_samps_max = dmatrix.n_samples_in_clusters
		Int samps_processed_max = dmatrix.total_samples_processed
		File? clusters_anno_bm = backmask_dmatrix.out_clusters
		Array[File]? cluster_dmatrices_bm = backmask_dmatrix.out_matrices
		Int? clusters_bm = backmask_dmatrix.n_clusters
		Int? clustered_samps_bm = backmask_dmatrix.n_samples_in_clusters
		Int? samps_processed_bm = backmask_dmatrix.total_samples_processed

		# sample information
		File? samples_input_tree = summarize_input_tree.samples
		File? samples_maximal_output_tree = summarize_after_reroot.samples
		File? samples_maximal_output_tree_before_reroot = summarize_before_reroot.samples    # iff defined(reroot_to_this_node)
		Array[String] samples_added = read_lines(special_samples_added)
		Array[String] samples_dropped = cat_diff_files.removed_files
		Array[File]  max_distance_matrix = dmatrix.out_matrices
		Array[File]? bm_distance_matrices = backmask_dmatrix.out_matrices
	}
}
