version 1.0

import "https://raw.githubusercontent.com/aofarrel/SRANWRP/v1.1.18/tasks/processing_tasks.wdl" as processing
import "../diffdiff/diffdiff.wdl" as dd
import "./matutils_and_friends.wdl" as matWDLlib

# Anything marked !ForwardReference is using a bogus fallback value with select_first().

workflow Cross_Sample_Masking_Test {
	input {
		Array[File] diffs
		
		# optional input - SNP distance matrix
		Boolean matrix_only_new_samples = false

		# optional inputs - filtering by coverage
		Array[File]? coverage_reports
		Float? max_low_coverage_sites
		
		# optional inputs - building trees
		Boolean detailed_clades = false
		File? input_tree                     # equivalent to UShER's i argument, if not defined, falls back to an SRA tree
		Boolean summarize_input_mat = true
		String? reroot_to_this_node          # equivalent to matUtils extract's y argument
		File? ref_genome                     # equivalent to USHER's ref argument
		File? metadata_tsv

		# output file names, extension not included
		Array[String]? rename_samples
		String out_prefix              = "CDPH"
		String out_prefix_summary      = out_prefix + "_"
		String in_prefix_summary       = basename(select_first([input_tree, "tb_alldiffs_mask2ref.L.fixed.pb"]))
		String out_diffs               = "_combined"
		String out_matrix              = "_matrix"
		String out_tree_annotated_pb   = "_annotated"
		String out_tree_nextstrain     = "_auspice"
		String out_tree_nwk            = "_nwk"
		String out_tree_taxonium       = "_taxonium"
		String out_tree_raw_pb         = "_raw"
		
	}

	parameter_meta {
		coverage_reports: "Single line text files generated by Lily's vcf to diff script, used to filter samples with low overall coverage"
		diffs: "Array of diff files"
		input_tree: "Input tree, equivalent to UShER's i argument"
		metadata_tsv: "TSV with one column of metadata"

		detailed_clades: "If true, run usher sampled diff with -D"
		make_nextstrain_subtrees: "If true, make nextstrain subtrees instead of one big nextstrain tree"
		matrix_only_new_samples: "If true, limit SNP distance matrix to only newly added samples"
		max_low_coverage_sites: "Maximum percentage of low coverage sites a sample can have before throwing it out"
		ref_genome: "Reference genome, equivalent to UShER's ref argument, default is H37Rv (M tuberculosis)"
		reroot_to_this_node: "Reroot the output tree relative to this node, leave blank to not reroot"
		out_prefix: "Prefix for all output files"
		subtree_only_new_samples: "If true and if make_nextstrain_subtrees true, nextstrain subtrees will only be focused on newly samples (ie samples added by your diffs)"
		summarize_input_mat: "If true and if an input tree is passed in, summarize that input tree"
	}

	call processing.cat_files as cat_maximal_diff_files {
		input:
			files = diffs,
			out_filename = out_prefix + out_diffs + ".diff",
			keep_only_unique_lines = false,
			removal_candidates = coverage_reports,
			removal_threshold = max_low_coverage_sites,
			first_lines_out_filename = "samples_added",
			overwrite_first_lines = rename_samples
	}

	File new_samples_added = select_first([cat_maximal_diff_files.first_lines, maximal_usher_sampled_diff.usher_tree]) #!ForwardReference

	if((summarize_input_mat)) {
		if (defined(input_tree)) {
			String basename_input_mat = basename(select_first([input_tree, ""]))

			# iff there is a metadata tsv, annotate input tree with it before summarizing
			if (defined(metadata_tsv)) {
				String annotated = "annotated_"
				call matWDLlib.annotate as annotate_input_tree {
					input:
						input_mat = select_first([input_tree, maximal_usher_sampled_diff.usher_tree]), #!ForwardReference
						metadata_tsv = select_first([metadata_tsv, maximal_usher_sampled_diff.usher_tree]), #!ForwardReference
						outfile_annotated = "input_annotated_" + basename_input_mat + ".pb"
				}
			}

			File possibly_annotated_input_tree = select_first([annotate_input_tree.annotated_tree, input_tree])
			String annotated_or_blank = select_first([annotated, ""])

			call matWDLlib.summarize as summarize_input_tree {
				input:
					input_mat = possibly_annotated_input_tree,
					prefix_outs = in_prefix_summary + annotated_or_blank
			}
		}
	}
	
	####################################################################
	####################################################################
	## maximal mode: if a newly added sample has a mask at a position ##
	## and another one doesn't, call that position                    ##
	####################################################################
	####################################################################

	call matWDLlib.usher_sampled_diff as maximal_usher_sampled_diff {
		input:
			detailed_clades = detailed_clades,
			diff = cat_maximal_diff_files.outfile,
			input_mat = input_tree,
			output_mat = "max" + out_prefix + out_tree_raw_pb + ".pb",
			ref_genome = ref_genome
	}

	if (defined(metadata_tsv)) {
		call matWDLlib.annotate as annotate_maximal {
			input:
				input_mat = maximal_usher_sampled_diff.usher_tree,
				metadata_tsv = select_first([metadata_tsv, maximal_usher_sampled_diff.usher_tree]), # bogus fallback
				outfile_annotated = "max" + out_prefix + out_tree_annotated_pb + ".pb"
		}
	}

	File possibly_annotated_maximal_tree = select_first([annotate_maximal.annotated_tree, maximal_usher_sampled_diff.usher_tree])

	if(defined(reroot_to_this_node)) {

		call matWDLlib.summarize as summarize_maximal_before_reroot {
			input:
				input_mat = possibly_annotated_maximal_tree,
				prefix_outs = "maximal_before_reroot"
		}

		call matWDLlib.reroot as reroot_maximal {
			input:
				input_mat = possibly_annotated_maximal_tree,
				reroot_to_this_node = select_first([reroot_to_this_node, ""])
		}
	}

	File final_maximal_tree = select_first([reroot_maximal.rerooted_tree, possibly_annotated_maximal_tree])

	# defined(metadata_tsv)   defined(reroot_to_this_node)          final_maximal_tree
	# ----------------------------------------------------------------------------------------------------------------
	#       true                       true                    annotated and rerooted
	#       true                      false                    annotated
	#       false                      true                    rerooted
	#       false                     false                    neither, just the output maximal_usher_sampled_diff.usher_tree

	call matWDLlib.convert_to_newick as maximal_newick {
		input:
			input_mat = final_maximal_tree,
			outfile_nwk = "max" + out_prefix + out_tree_nwk + ".nwk"
	}

	call matWDLlib.convert_to_taxonium as maximal_taxonium {
		input:
			input_mat = final_maximal_tree,
			outfile_taxonium = "max" + out_prefix + out_tree_taxonium + ".jsonl.gz"
	}
	
	call matWDLlib.convert_to_nextstrain_single as maximal_auspice {
		input:
			input_mat = final_maximal_tree,
			outfile_nextstrain = "max" + out_prefix + out_tree_nextstrain + ".json",
			metadata_files = []
	}

	call matWDLlib.matrix as maximal_dmatrix {
		input:
			input_nwk = maximal_newick.newick_tree,
			special_samples = new_samples_added,
			only_matrix_special_samples = matrix_only_new_samples,
			outfile_matrix = "max" + out_prefix + out_matrix + ".tsv"
	}

	call matWDLlib.summarize as summarize_maximal {
		input:
			input_mat = final_maximal_tree,
			prefix_outs = "max" + out_prefix_summary
	}
	
	####################################################################
	####################################################################
	## minimal mode: if a newly added sample has a mask at a position ##
	## and another one doesn't, mask that position                    ##
	####################################################################
	####################################################################
	
	call dd.diffdiff_usher_mask as make_minimal_mask {
		input:
			diffs = diffs
	}
	
	call matWDLlib.mask as mask {
        input:
            input_mat = maximal_usher_sampled_diff.usher_tree,
            mask_tsv = make_minimal_mask.usher_mask
    }

	if (defined(metadata_tsv)) {
		call matWDLlib.annotate as annotate_minimal {
			input:
				input_mat = mask.masked_tree,
				metadata_tsv = select_first([metadata_tsv, mask.masked_tree]), # bogus fallback
				outfile_annotated = "min" + out_prefix + out_tree_annotated_pb + ".pb"
		}
	}

	File possibly_annotated_minimal_output_tree = select_first([annotate_minimal.annotated_tree, mask.masked_tree])

	if(defined(reroot_to_this_node)) {

		call matWDLlib.summarize as summarize_minimal_before_reroot {
			input:
				input_mat = possibly_annotated_minimal_output_tree,
				prefix_outs = "minimal_before_reroot"
		}

		call matWDLlib.reroot as reroot_minimal {
			input:
				input_mat = possibly_annotated_minimal_output_tree,
				reroot_to_this_node = select_first([reroot_to_this_node, ""])
		}
	}

	File final_minimal_output_tree = select_first([reroot_minimal.rerooted_tree, possibly_annotated_minimal_output_tree])

	call matWDLlib.convert_to_newick as minimal_newick {
		input:
			input_mat = final_minimal_output_tree,
			outfile_nwk = "min" + out_prefix + out_tree_nwk + ".nwk"
	}

	call matWDLlib.convert_to_taxonium as minimal_taxonium {
		input:
			input_mat = final_minimal_output_tree,
			outfile_taxonium = "min" + out_prefix + out_tree_taxonium + ".jsonl.gz"
	}
	
	call matWDLlib.convert_to_nextstrain_single as minimal_auspice {
		input:
			input_mat = final_minimal_output_tree,
			outfile_nextstrain = "min" + out_prefix + out_tree_nextstrain + ".json",
			metadata_files = []
	}

	call matWDLlib.matrix as minimal_dmatrix {
		input:
			input_nwk = minimal_newick.newick_tree,
			special_samples = new_samples_added,
			only_matrix_special_samples = matrix_only_new_samples,
			outfile_matrix = "min" + out_prefix + out_matrix + ".tsv"
	}

	call matWDLlib.summarize as summarize_minimal {
		input:
			input_mat = final_minimal_output_tree,
			prefix_outs = "min" + out_prefix_summary
	}
	
	####################################################################
	####################################################################
	## backmask mode: like minimal mode, except instead of masking an ##
	## existing maximal tree, we make one from backmasked diffs       ##
	####################################################################
	####################################################################
	
	call dd.diffdiff_backmask as backmask {
		input:
			diffs = diffs
	}
	
	call processing.cat_files as cat_backmasked_diff_files {
		input:
			files = backmask.backmasked_diffs,
			out_filename = "BM" + out_prefix + out_diffs + ".diff",
			keep_only_unique_lines = false,
			removal_candidates = coverage_reports,
			removal_threshold = max_low_coverage_sites,
			first_lines_out_filename = "backmasked_samples_added",
			overwrite_first_lines = rename_samples
	}
	
	call matWDLlib.usher_sampled_diff as backmask_usher_sampled_diff {
		input:
			detailed_clades = detailed_clades,
			diff = cat_backmasked_diff_files.outfile,
			input_mat = input_tree,
			output_mat = "bm" + out_prefix + out_tree_raw_pb + ".pb",
			ref_genome = ref_genome
	}

	if (defined(metadata_tsv)) {
		call matWDLlib.annotate as annotate_backmasked {
			input:
				input_mat = backmask_usher_sampled_diff.usher_tree,
				metadata_tsv = select_first([metadata_tsv, backmask_usher_sampled_diff.usher_tree]), # bogus fallback
				outfile_annotated = "bm" + out_prefix + out_tree_annotated_pb + ".pb"
		}
	}

	File possibly_annotated_backmask_output_tree = select_first([annotate_backmasked.annotated_tree, backmask_usher_sampled_diff.usher_tree])

	if(defined(reroot_to_this_node)) {

		call matWDLlib.summarize as summarize_backmask_before_reroot {
			input:
				input_mat = possibly_annotated_backmask_output_tree,
				prefix_outs = "backmask_before_reroot"
		}

		call matWDLlib.reroot as reroot_backmask {
			input:
				input_mat = possibly_annotated_backmask_output_tree,
				reroot_to_this_node = select_first([reroot_to_this_node, ""])
		}
	}

	File final_backmask_tree = select_first([reroot_backmask.rerooted_tree, possibly_annotated_backmask_output_tree])

	call matWDLlib.convert_to_newick as backmask_newick {
		input:
			input_mat = final_backmask_tree,
			outfile_nwk = "bm" + out_prefix + out_tree_nwk + ".nwk"
	}

	call matWDLlib.convert_to_taxonium as backmask_taxonium {
		input:
			input_mat = final_backmask_tree,
			outfile_taxonium = "bm" + out_prefix + out_tree_taxonium + ".jsonl.gz"
	}

	call matWDLlib.convert_to_nextstrain_single as backmask_auspice {
		input:
			input_mat = final_backmask_tree,
			outfile_nextstrain = "bm" + out_prefix + out_tree_nextstrain + ".json",
			metadata_files = []
	}
	
	File backmasked_sample_names = select_first([cat_backmasked_diff_files.first_lines, maximal_usher_sampled_diff.usher_tree])

	call matWDLlib.matrix as backmask_dmatrix {
		input:
			input_nwk = backmask_newick.newick_tree,
			special_samples = backmasked_sample_names,
			only_matrix_special_samples = matrix_only_new_samples,
			outfile_matrix = "bm" + out_prefix + out_matrix + ".tsv"
	}

	call matWDLlib.summarize as summarize_backmask {
		input:
			input_mat = final_backmask_tree,
			prefix_outs = "bm" + out_prefix_summary
	}
	
	output {
		# trees - protobuff
		File max_usher = maximal_usher_sampled_diff.usher_tree                                 
		File? max_usher_rr = reroot_maximal.rerooted_tree
		File? max_usher_anno = annotate_maximal.annotated_tree
		File min_usher = mask.masked_tree
		File? min_usher_rr = reroot_minimal.rerooted_tree
		File? min_usher_anno = annotate_minimal.annotated_tree 
		File bm_usher = backmask_usher_sampled_diff.usher_tree
		File? bm_usher_rr = reroot_backmask.rerooted_tree
		File? bm_usher_anno = annotate_backmasked.annotated_tree

		# trees - other formats
		File max_nwk = maximal_newick.newick_tree
		File max_taxonium = maximal_taxonium.taxonium_tree
		File max_nextstrain = maximal_auspice.nextstrain_singular_tree 
		File min_nwk = minimal_newick.newick_tree
		File min_taxonium = minimal_taxonium.taxonium_tree
		File min_nextstrain = minimal_auspice.nextstrain_singular_tree
		File bm_nwk = backmask_newick.newick_tree
		File bm_taxonium = backmask_taxonium.taxonium_tree
		File bm_nextstrain = backmask_auspice.nextstrain_singular_tree

		# other
		File max_distance_matrix = maximal_dmatrix.out_matrix
		File min_distance_matrix = minimal_dmatrix.out_matrix
		File bm_distance_matrix = backmask_dmatrix.out_matrix
	}
}